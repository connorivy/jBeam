{% extends "beam/index.html" %}
{% load static %}

{% block threejs %}

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.130.1';
    import * as TWEEN from "https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.esm.js";
    import { GUI } from 'https://cdn.skypack.dev/three@0.130.1/examples/jsm/libs/dat.gui.module.js';
    import { MapControls } from 'https://cdn.skypack.dev/three@0.130.1/examples/jsm/controls/OrbitControls.js';
    import { Line2 } from 'https://cdn.skypack.dev/three@0.130.1/examples/jsm/lines/Line2.js';
    import { LineMaterial } from 'https://cdn.skypack.dev/three@0.130.1/examples/jsm/lines/LineMaterial.js';
    import { LineGeometry } from 'https://cdn.skypack.dev/three@0.130.1/examples/jsm/lines/LineGeometry.js';
    import { BufferGeometryUtils } from 'https://cdn.skypack.dev/three@0.130.1/examples/jsm/utils/BufferGeometryUtils.js';
    import { GLTFLoader } from 'https://cdn.skypack.dev/three@0.130.1/examples/jsm/loaders/GLTFLoader.js';
    // import { FontLoader } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/FontLoader.js';
    

    let camera, controls, scene, renderer;
    let stats, gpuPanel;
    let INTERSECTED, CLICKED;
    let lineMat;
    let lineMats = [];
    let ticks = [];

    let beam;
    let clickColor = new THREE.Color(0x0000ff);
    let beamHeight = 8;
    let coneHeight = -8;
    let cylheight_max = 14;
    let cylheight_min = 5;
    let cylThickness = .5;
    let gui;
    let initialCamPos = new THREE.Vector3(4,-790,4);
    let profileCamPos = new THREE.Vector3(-700,0,0);
    // let initialCamPos = new THREE.Vector3(-313,-945,169);

    let axisY = -24;
    let axisHeight = 4;

    let colorList = [
        0xFFFFB300, //Vivid Yellow
        0xFF803E75, //Strong Purple
        0xFFFF6800, //Vivid Orange
        0xFFA6BDD7, //Very Light Blue
        0xFFC10020, //Vivid Red
        0xFFCEA262, //Grayish Yellow
        0xFF817066, //Medium Gray

        //The following will not be good for people with defective color vision
        0xFF007D34, //Vivid Green
        0xFFF6768E, //Strong Purplish Pink
        // 0xFF00538A, //Strong Blue
        0xFFFF7A5C, //Strong Yellowish Pink
        0xFF53377A, //Strong Violet
        0xFFFF8E00, //Vivid Orange Yellow
        0xFFB32851, //Strong Purplish Red
        0xFFF4C800, //Vivid Greenish Yellow
        0xFF7F180D, //Strong Reddish Brown
        0xFF93AA00, //Vivid Yellowish Green
        0xFF593315, //Deep Yellowish Brown
        0xFFF13A13, //Vivid Reddish Orange
        0xFF232C16, //Dark Olive Green

        // 0xFFA6BDD7, //Very Light Blue
        // 0xFFFFB300, //Vivid Yellow
        // 0xFFC10020, //Vivid Red
    ];

    {% block modelClasses %} {% endblock modelClasses %}

    const pointer = new THREE.Vector2();
    const mouse = new THREE.Vector2();
    const raycaster = new THREE.Raycaster();

    init();
    // render(); // remove when using next line for animation loop (requestAnimationFrame)
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xf9fafc );
        // scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );
        const canvas = document.querySelector("#threejs-container canvas");

        renderer = new THREE.WebGLRenderer( { canvas: canvas, antialias: true } );

        const loader = new GLTFLoader();
        loader.load("{% static 'beam/scene.gltf' %}", function(gltf) {
            var model = gltf.scene
            var metal = new THREE.MeshStandardMaterial( {

                color: 0xffffff,

                roughness: .8,
                metalness: 1,

                // roughnessMap: roughnessMap,
                // metalnessMap: metalnessMap,

                // envMap: envMap, // important -- especially for metals!
                // envMapIntensity: envMapIntensity

            } );
            model.traverse((o) => {
                if (o.isMesh) o.material = metal;
            });
            model.rotation.x = Math.PI / 2
            // model.rotation.y = 9/16 * Math.PI
            model.rotation.y = Math.PI / 2

            // model.scale(new THREE.Vector3(3,1,1))

            scene.add(model)
        }, undefined, function ( error ) {

            console.error( error );

        } );


        // There's no reason to set the aspect here because we're going
        // to set it every frame anyway so we'll set it to 2 since 2
        // is the the aspect for the canvas default size (300w/150h = 2)
        camera = new THREE.PerspectiveCamera(5.5, 2, 1, 5000);
        camera.up = new THREE.Vector3( 0, 0, 1 );   
        camera.position.set( initialCamPos.x, initialCamPos.y, initialCamPos.z );

        var controls = new MapControls(camera, renderer.domElement);
        controls.screenSpacePanning = true;
        controls.enablePan = true;

        controls.maxPolarAngle = Math.PI / 2;
        controls.mouseButtons = {MIDDLE: THREE.MOUSE.RIGHT, RIGHT: THREE.MOUSE.RIGHT};


        // scene.add(new THREE.GridHelper(1000, 100));

        // Beam(L, E, I, A, Lcant, Rcant, left_support_type, right_support_type)
        beam = new Beam({{ beam_object.L }}, 29000, 2900, 16, 0, 0, 'pin', 'pin');

        // draw arrows 
        {% for pl in point_loads %}
        beam.defineLoad({{ pl.startMagnitude }}, {{ pl.startLocation}})
        beam.drawLoad(beam.PLs.at(-1))
        {% endfor %}

        {% for dl in distributed_loads %}
        beam.defineLoad({{ dl.startMagnitude }}, {{ dl.startLocation}}, {{ dl.endLocation }}, {{ dl.endMagnitude }})
        beam.drawLoad(beam.DLs.at(-1))
        {% endfor %}

        
        // materials
        lineMat = new LineMaterial( {
            color: 0xdddddd,
            linewidth: 3, // in pixels
            vertexColors: false,
            //resolution:  // to be set by renderer, eventually
            dashed: false,
            alphaToCoverage: true,
        } );

        drawLine([[-100,0,axisY+axisHeight],[-100, 0, axisY-axisHeight]]);
        drawLine([[100,0,axisY+axisHeight],[100, 0, axisY-axisHeight]]);
        drawLine([[-100,0,axisY],[110, 0, axisY]]);
        drawLine([[110,0,axisY],[106, 0, axisY+axisHeight-1]]);
        drawLine([[110,0,axisY],[106, 0, axisY-axisHeight+1]]);

        // world

        const geometry = new THREE.ConeGeometry( 5, 10, 25 );
        const material = new THREE.MeshStandardMaterial( {color: 0x00ff00, metalness: 0.5, roughness: 0.5,} );
        var cylinder = new THREE.Mesh( geometry, material );
        define_userData(cylinder, 'support', cylinder.material.color.getHex(), 0);
        cylinder.position.x = -100
        cylinder.position.z = -12
        cylinder.rotation.x = Math.PI / 2;
        cylinder.rotation.y = Math.PI / 8;
        scene.add( cylinder );

        const material2 = new THREE.MeshStandardMaterial( {color: 0x00ff00, metalness: 0.5, roughness: 0.5,} );
        var cylinder2 = new THREE.Mesh( geometry, material2 );
        define_userData(cylinder2, 'support', cylinder2.material.color.getHex(), 1);
        cylinder2.position.x = 100
        cylinder2.position.z = -13
        cylinder2.rotation.x = Math.PI / 2;
        cylinder2.rotation.y = Math.PI / 8;
        scene.add( cylinder2 );

        // lights

        const dirLight1 = new THREE.DirectionalLight( 0xffffff );
        dirLight1.position.set( 0, -100, 100 );
        scene.add( dirLight1 );

        // const dirLight2 = new THREE.DirectionalLight( 0x002288 );
        // dirLight2.position.set( - 1, - 1, - 1 );
        // scene.add( dirLight2 );

        const ambientLight = new THREE.AmbientLight( 0x999999 );
        scene.add( ambientLight );

        // const directionalLightHelper = new THREE.PointLightHelper(dirLight1, 20);
        // scene.add( directionalLightHelper );

        //

        window.addEventListener( 'resize', resizeCanvasToDisplaySize );
        document.addEventListener( 'mousemove', onMouseMove );
        canvas.addEventListener( 'click', onClick );
        document.addEventListener('keyup', onKeyUp);
        resizeCanvasToDisplaySize();

        // var target = new THREE.Vector3(10, -20, 20); // create on init
        // animateVector3(camera.position, target, {
            
        //     duration: 5000, 
            
        //     easing : TWEEN.Easing.Quadratic.InOut,
            
        //     update: function(d) {
        //         console.log("Updating: " + d);
        //     },
            
        //     callback : function(){
        //         console.log("Completed");
        //     }
        // });
        // initGui();

        // const gui = new GUI();
        // gui.add( controls, 'screenSpacePanning' );

    }

    function initGui() {

        gui = new GUI();

        const param = {
            'Beam Length': 30,
        };

        gui.add( param, 'Beam Length', 1, 80 ).onChange( function ( val ) {

            beam.L = val;

        } );
    }

    function switchCamera() {
        animateVector3(camera.position, profileCamPos, {
            
            duration: 2000, 
            
            easing : TWEEN.Easing.Quadratic.InOut,
            
            update: function(d) {
                console.log("Updating: " + d);
            },
            
            callback : function(){
                console.log("Completed");
            }
        });
    }

    function animateVector3(vectorToAnimate, target, options){
        options = options || {};
        // get targets from options or set to defaults
        var to = target || THREE.Vector3(),
            easing = options.easing || TWEEN.Easing.Quadratic.In,
            duration = options.duration || 2000;
        // create the tween
        var tweenVector3 = new TWEEN.Tween(vectorToAnimate)
            .to({ x: to.x, y: to.y, z: to.z, }, duration)
            .easing(easing)
            .onUpdate(function(d) {
                if(options.update){ 
                    options.update(d);
                }
            })
            .onComplete(function(){
            if(options.callback) options.callback();
            });
        // start the tween
        tweenVector3.start();
        // return the tween in case we want to manipulate it later on
        return tweenVector3;
    }

    function define_userData(mesh, type, color, index, tickIndex=null) {
        // define og_color and highlighted color
        mesh.userData.index = index
        mesh.userData.type = type
        mesh.userData.og_color = color;
        mesh.userData.highlight_color = new THREE.Color(mesh.userData.og_color);
        mesh.userData.highlight_color.lerp(clickColor, .5);
        mesh.userData.tickIndex = tickIndex;
    }

    function set_max_point_load(beam) {
        var max=0;
        var maxIndex=0;
        for (var i=0; i<beam.PLs.length; i++) {
            beam.PLs[i].isMaxPL = false;
            if (beam.PLs[i].startMagnitude > max) {
                max = beam.PLs[i].startMagnitude;
                maxIndex = i;
            }
        }
        beam.maxPL = max;
        beam.PLs[maxIndex].isMaxPL = true;
    }

    function redrawPointLoads(beam, index) {
        for (var i=0; i<beam.PLs.length; i++) {
            if (!i==index){
                beam.drawLoad(beam.PLs[i]);
            }
        }
    }

    function set_max_dist_load(beam) {
        var max=0;
        var maxIndex=0;
        for (var i=0; i<beam.DLs.length; i++) {
            if (beam.DLs[i].startMagnitude > max) {
                max = beam.DLs[i].startMagnitude;
                maxIndex = i;
            }
        }
        if (!beam.DLs[maxIndex]) {
            beam.DLs[maxIndex].isMaxDL = true;
            for (var i=0; i<beam.DLs.length; i++) {
                beam.drawLoad(beam.DLs[i]);
            }
        }
        // beam.DLs[maxIndex].isMaxDL = true;
        beam.maxDL = max;
    }

    function drawLine(user_points, material) {
        // geometries
        const points = [];
        for (var i=0; i<user_points.length; i++) {
            points.push(user_points[i][0],user_points[i][1],user_points[i][2])
        }

        var lineGeo = new LineGeometry();
        lineGeo.setPositions(points)

        // lineMat.color.set(color);

        var line = new Line2( lineGeo, material );
        line.computeLineDistances();
        line.scale.set( 1, 1, 1 );

        return line
        // scene.add( line );
    }

    function createVector(x, y, z, camera, width, height) {
        var p = new THREE.Vector3(x, y, z);
        var temp = new THREE.Vector3(0,0,0);
        // this muct be called or the result of this function on load will not be correct
        camera.getWorldPosition(temp);
        var vector = p.project(camera);

        vector.x = (vector.x + 1) / 2 * width;
        vector.y = -(vector.y - 1) / 2 * height;

        return vector;
    };

    function resizeCanvasToDisplaySize() {
        const canvas = renderer.domElement;
        // look up the size the canvas is being displayed
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;     

        // adjust displayBuffer size to match
        if (canvas.width !== width || canvas.height !== height) {
            // you must pass false here or three.js sadly fights the browser
            renderer.setSize(width, height, false);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            // update camera position
            var vFOV = THREE.MathUtils.degToRad( camera.fov ); // convert vertical fov to radians
            var desired_screen_width = 220;
            var desired_screen_height = 79;

            var dist_for_height = desired_screen_height / ( 2 * Math.tan(vFOV/2) )
            var dist_for_width = desired_screen_width / ( 2 * Math.tan(vFOV/2) * camera.aspect )

            var dist = Math.max(dist_for_height, dist_for_width)

            var multiplier = dist / Math.sqrt(initialCamPos.x*initialCamPos.x+initialCamPos.y*initialCamPos.y+initialCamPos.z*initialCamPos.z) // I'm essentially linearly interpolating the camera on this line
            camera.position.set( initialCamPos.x*multiplier, initialCamPos.y*multiplier, initialCamPos.z*multiplier );
            camera.lookAt(initialCamPos.x*multiplier, 0, initialCamPos.z*multiplier);

            // set matLine resolution
            lineMat.resolution.set( width, height );
            console.log(lineMats.length)

            //calculate text locations
            var rect = canvas.getBoundingClientRect();
            var beamLenTag = document.getElementById('beamLenTag');
            // beamLenTag.innerHTML = beam.L;
            beamLenTag.style.fontSize = 1 / multiplier * 25 + 'px'; // maybe change this from px to have a more scalable webpage
            var vect = createVector(100, 0, -29, camera, rect.width, rect.height);

            beamLenTag.style.top = vect.y + rect.top + 'px';
            beamLenTag.style.left = vect.x  - beamLenTag.clientWidth / 2 + rect.left + 'px';      
        }
        // this must happen even if canvas doesn't resize, so put it outside the if statement
        for (var i=0; i<lineMats.length; i++) {
            lineMats[i].resolution.set( width, height);
        }
    }

    function onMouseMove( event ) {

        // calculate mouse position in normalized device coordinates
        // (-1 to +1) for both components

        var rect = renderer.domElement.getBoundingClientRect();

        mouse.x = ( ( event.clientX - rect.left ) / ( rect.width ) ) * 2 - 1;
        mouse.y = - ( ( event.clientY - rect.top ) / ( rect.height) ) * 2 + 1;
    }

    function onClick( event ) {
        // console.log(camera.position);
        // if an item is intersected and it isn't a line or tick mark
        if (INTERSECTED && INTERSECTED.userData.line==null) {
            // if there is a mesh that has been clicked previously, change it back to its og_color
            if (CLICKED) { 
                CLICKED.material.color.set( CLICKED.userData.og_color );
                for (var i=0; i<ticks[CLICKED.userData.tickIndex].length; i++) {
                    ticks[CLICKED.userData.tickIndex][i].material.color.set( 0x000000 );
                }
            }
            CLICKED = INTERSECTED;
            CLICKED.material.color.set( 0x0000ff );

            // if the clicked element has a tick mark associated with it, turn that blue as well
            for (var i=0; i<ticks[CLICKED.userData.tickIndex].length; i++) {
                ticks[CLICKED.userData.tickIndex][i].material.color.set( 0x0000ff );
            }

            // // set value of hidden primary key field to the load index
            // $("#form-index").val(+parseInt(CLICKED.userData.index).toFixed(4));
            // $('#form-startMagnitude').val(beam.PLs.at(CLICKED.userData.index).startMagnitude)
            // $('#form-startLocation').val(beam.PLs.at(CLICKED.userData.index).startLocation)
        }
        else if (CLICKED) {
            CLICKED.material.color.set( CLICKED.userData.og_color );
            for (var i=0; i<ticks[CLICKED.userData.tickIndex].length; i++) {
                    ticks[CLICKED.userData.tickIndex][i].material.color.set( 0x000000 );
            }
            CLICKED = null;

            // // set value of hidden primary key field to null
            // $("#form-index").val('');
            // $('#form-startMagnitude').val('')
            // $('#form-startLocation').val('')
        }
    }

    function onKeyUp( event ) {
        // console.log(event.code)
        if (event.code === "Tab") {
            console.log('tab');
        } else if (event.code === 'Slash') {
            console.log('/');
            console.log(camera.position);
            switchCamera();
        }
    }

    function animate() {

        requestAnimationFrame( animate );

        TWEEN.update();

        //controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

        render();

    }


    function render() {
        // // main scene
        // renderer.setViewport( 0, 0, window.innerWidth, window.innerHeight );
        // update the picking ray with the camera and mouse position
        raycaster.setFromCamera( mouse, camera );

        // calculate objects intersecting the picking ray
        const intersects = raycaster.intersectObjects( scene.children );

        // turns the topmost raycasted line blue and then turns it back to its OG color
        if ( intersects.length > 0 ) {
            // if something is raycasted that is different than what was previously raycasted
            if ( INTERSECTED != intersects[ 0 ].object ) {
                // reset old color
                if ( INTERSECTED ) {
                    INTERSECTED.material.color.set(INTERSECTED.userData.og_color);
                }
                INTERSECTED = intersects[ 0 ].object;
                if (INTERSECTED != CLICKED) INTERSECTED.material.color.set( INTERSECTED.userData.highlight_color );
            }
        } else if (INTERSECTED) {
            if ( INTERSECTED != CLICKED) INTERSECTED.material.color.set( INTERSECTED.userData.og_color );
            INTERSECTED = null;
        }            

        renderer.render( scene, camera );

        // console.log(camera.position)

    }

    {% block ajaxRequests %} {% endblock ajaxRequests %}

</script>

{% endblock threejs %}